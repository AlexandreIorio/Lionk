name: Check PR Title and Update Project Versions

on:
  pull_request:
    branches:
      - test

jobs:
  check-pr-title:
    runs-on: ${{ vars.RUNNER_DISTRIBUTION }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@v3

    - name: Get pull request title and body
      id: get_pr_info
      run: |
        echo "PR_TITLE<<EOF" >> $GITHUB_ENV
        echo "${{ github.event.pull_request.title }}" >> $GITHUB_ENV
        echo "EOF" >> $GITHUB_ENV
        echo "PR_BODY<<EOF" >> $GITHUB_ENV
        echo "${{ github.event.pull_request.body }}" >> $GITHUB_ENV
        echo "EOF" >> $GITHUB_ENV

    - name: Process PR title, body, and check projects
      id: process_title_body
      run: |
        PR_TITLE="${{ env.PR_TITLE }}"
        PR_BODY="${{ env.PR_BODY }}"
        SRC_PATH="./src_test/"

        echo "Pull Request title: $PR_TITLE"
        echo "Pull Request body: $PR_BODY"

        # Extract project names and version types from the PR title
        pairs=$(echo "$PR_TITLE" | grep -oE '\b\w+\b (major|minor|patch)')
        if [ -z "$pairs" ]; then
          echo "Pull Request title does not contain version change indication (major, minor, patch)."
          exit 0
        fi

        # Initialize arrays
        declare -a projects
        declare -a types
        declare -a oldversions
        declare -a newversions
        declare -a changelogs

        # Split projects and types into arrays
        while IFS= read -r pair; do
          project=$(echo "$pair" | awk '{print $1}')
          type=$(echo "$pair" | awk '{print $2}')
          projects+=("$project")
          types+=("$type")
        done <<< "$pairs"

        # Show projects and types
        echo "Projects: ${projects[@]}"
        echo "Types: ${types[@]}"

        # Validate types
        for type in "${types[@]}"; do
          if [[ "$type" != "major" && "$type" != "minor" && "$type" != "patch" ]]; then
            echo "Invalid version type: $type"
            exit 1
          fi
        done

        echo "All version types are valid."

        # Check if project file exists
        for project in "${projects[@]}"; do
          if [ ! -f "$SRC_PATH/$project/$project.csproj" ]; then
            echo "Project file not found: $SRC_PATH/$project/$project.csproj"
            exit 1
          fi
        done

        echo "All project files exist."

        # Extract changelogs from PR body
        extract_changelogs() {
          local body="$1"
          local projects=("$@")
          local project_changelogs=()

          for project in "${projects[@]:1}"; do
            changelog=$(echo "$body" | awk -v proj="$project" '
              BEGIN { in_project = 0; }
              {
                if ($0 ~ proj && $0 !~ /^- /) {
                  in_project = 1;
                } else if ($0 !~ /^- /) {
                  in_project = 0;
                }
                if (in_project && $0 ~ /^- /) {
                  print;
                }
              }')
            project_changelogs+=("$changelog")
          done

          echo "${project_changelogs[@]}"
        }

        changelogs=$(extract_changelogs "$PR_BODY" "${projects[@]}")

        # Show changelogs
        IFS=$'\n' read -rd '' -a changelogs_array <<<"$changelogs"
        for i in "${!projects[@]}"; do
          echo "Changelog for ${projects[$i]}:"
          echo "${changelogs_array[$i]}"
        done

        # Loop through each project and type to populate oldversions and newversions arrays
        for i in "${!projects[@]}"; do
          project=${projects[$i]}
          type=${types[$i]}
          csproj="$SRC_PATH/$project/$project.csproj"
          oldversion=$(grep -oPm1 "(?<=<version>)[^<]+" "$csproj")
          oldversions+=("$oldversion")
          
          IFS='.' read -r -a version_parts <<< "$oldversion"
          major=${version_parts[0]}
          minor=${version_parts[1]}
          patch=${version_parts[2]}

          if [[ "$type" == "major" ]]; then
            major=$((major + 1))
            minor=0
            patch=0
          elif [[ "$type" == "minor" ]]; then
            minor=$((minor + 1))
            patch=0
          elif [[ "$type" == "patch" ]]; then
            patch=$((patch + 1))
          fi

          newversion="$major.$minor.$patch"
          newversions+=("$newversion")

          echo "$project old version: $oldversion, new version: $newversion"
        done

        # Save data to artifact
        echo "${projects[@]}" > projects.txt
        echo "${types[@]}" > types.txt
        echo "${oldversions[@]}" > oldversions.txt
        echo "${newversions[@]}" > newversions.txt
        echo "${changelogs_array[@]}" > changelogs.txt

    - name: Upload project data artifact
      uses: actions/upload-artifact@v3
      with:
        name: project-data
        path: |
          projects.txt
          types.txt
          oldversions.txt
          newversions.txt
          changelogs.txt





  # publish-nuget:
  #   runs-on: ${{ vars.RUNNER_DISTRIBUTION }}
  #   needs: check-pr-title

  #   steps:
  #     - name: Checkout repository
  #       uses: actions/checkout@v3

  #     - name: Download project data artifact
  #       uses: actions/download-artifact@v3
  #       with:
  #         name: project-data

  #     - name: Setup .NET Core
  #       uses: actions/setup-dotnet@v3
  #       with:
  #         dotnet-version: ${{ vars.DOTNET_VERSION }}

  #     - name: Load project data
  #       run: |
  #         echo "PROJECTS=$(cat projects.txt)" >> $GITHUB_ENV
  #         echo "NEW_VERSION=$(cat newversions.txt)" >> $GITHUB_ENV
  #         echo "SRC_PATH=src_test/" >> $GITHUB_ENV

  #     - name: Publish NuGet packages
  #       run: |
  #           projects=(${{ env.PROJECTS }})
  #           newversions=(${{ env.NEW_VERSION }})
  #           SRC_PATH=${{ env.SRC_PATH }}
    
  #           for i in "${!projects[@]}"; do
  #             project=${projects[$i]}
  #             newversion=${newversions[$i]}
  #             csproj="$SRC_PATH/$project/$project.csproj"
    
  #             echo "Publishing $csproj as version $newversion"
    
  #             dotnet pack "$csproj" -p:PackageVersion="$newversion" -o ./output
  #             dotnet nuget push "./output/$project.$newversion.nupkg" -k ${{ secrets.GH_TOKEN }} -s "https://nuget.pkg.github.com/alexandreiorio/index.json"
  #           done

  # update-csproj:
  #   permissions:
  #     contents: write
  #   runs-on: ${{ vars.RUNNER_DISTRIBUTION }}
  #   needs: publish-nuget

  #   steps:
  #   - name: Checkout repository
  #     uses: actions/checkout@v3
  #     with:
  #       ref: ${{ github.head_ref }}

  #   - name: Download project data artifact
  #     uses: actions/download-artifact@v3
  #     with:
  #       name: project-data

  #   - name: Load project data
  #     run: |
  #       echo "PROJECTS=$(cat projects.txt)" >> $GITHUB_ENV
  #       echo "NEW_VERSION=$(cat newversions.txt)" >> $GITHUB_ENV
  #       echo "SRC_PATH=src_test/" >> $GITHUB_ENV

  #   - name: Update .csproj files
  #     run: |

  #       projects=(${{ env.PROJECTS }})
  #       newversions=(${{ env.NEW_VERSION }})
  #       SRC_PATH=(${{ env.SRC_PATH }})

  #       # Update the .csproj files with new versions
  #       for i in "${!projects[@]}"; do
  #         project=${projects[$i]}
  #         newversion=${newversions[$i]}
  #         csproj="$SRC_PATH/$project/$project.csproj"
  #         temp_csproj="$SRC_PATH/$project/temp_$project.csproj"
  #         echo "Updating $csproj to version $newversion"
          
  #         # Copy to a temporary file
  #         cp "$csproj" "$temp_csproj"
          
  #         # Update the version in the temporary file
  #         awk -v newversion="$newversion" '
  #         BEGIN { FS = OFS = "" }
  #         /<version>/ { $0 = gensub(/<version>.*<\/version>/, "<version>" newversion "</version>", 1) }
  #         { print }
  #         ' "$temp_csproj" > "$csproj"
          
  #         rm "$temp_csproj"

  #         echo "Updated $csproj content:"
  #         cat "$csproj"
  #       done

  #   - name: Commit and push changes
  #     run: |
  #       projects=(${{ env.PROJECTS }})
  #       newversions=(${{ env.NEW_VERSION }})
  #       SRC_PATH=(${{ env.SRC_PATH }})

  #       git config --global user.name '${{ vars.BOT_NAME}}'
  #       git config --global user.email '${{ vars.BOT_MAIL}}'
  #       for project in "${projects[@]}"; do
  #         git add "$SRC_PATH/$project/$project.csproj"
  #       done
  #       git commit -m "Update project versions"
  #       git push origin HEAD:${{ github.head_ref }}

  # create-tag-and-release:
  #   permissions:
  #     contents: write
  #   runs-on: ${{ vars.RUNNER_DISTRIBUTION }}
  #   needs: update-csproj

  #   steps:
  #   - name: Checkout repository
  #     uses: actions/checkout@v3

  #   - name: Download project data artifact
  #     uses: actions/download-artifact@v3
  #     with:
  #       name: project-data

  #   - name: Create tags and releases
  #     env:
  #       GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  #     run: |
  #       projects=($(cat projects.txt))
  #       newversions=($(cat newversions.txt))
  #       # Show projects and types
  #       echo "Projects: ${projects[@]}"
  #       echo "new versions: ${newversions[@]}"

  #       for i in "${!projects[@]}"; do
  #           project=${projects[$i]}
  #           newversion=${newversions[$i]}
  #           tag="${project}_v${newversion}"

  #           echo "Creating tag $tag"

  #           git config --global user.name '${{ vars.BOT_NAME}}'
  #           git config --global user.email '${{ vars.BOT_MAIL}}'

  #           # Create the tag
  #           git tag -a "$tag" -m "Release $tag"
  #           git push origin "$tag"

  #           # Create the release
  #           gh release create "$tag" --title "$tag" --notes "Release of version $newversion for $project"
  #       done

